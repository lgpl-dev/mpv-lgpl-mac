name: Build and Release mpv

on:
  workflow_dispatch:
    inputs:
      version:
        description: 'mpvのバージョン (例: v0.38.0)'
        required: true
        default: 'v1.0.0'

jobs:
  build_and_release:
    runs-on: macos-13
    
    steps:
    - name: チェックアウト
      uses: actions/checkout@v4

    - name: Homebrew環境のセットアップ
      run: |
        # ffmpegとmpvのlgplタップを追加
        brew tap lgpl-dev/ffmpeg-lgpl
        brew tap lgpl-dev/mpv-lgpl
        # 必要なパッケージをインストール
        brew install ffmpeg-lgpl mpv-lgpl python
        # otoolやinstall_name_toolがパスにあるか確認
        which otool
        which install_name_tool

    - name: スクリプトの保存と実行
      id: run_script
      run: |
        # Pythonスクリプトをファイルとして保存
        cat << 'EOF' > build_mpv.py
        import subprocess
        import re
        import os
        import shutil

        def get_linked_and_real_paths(filepaths, filter_prefixes):
            """
            指定されたファイルのdylib依存関係を再帰的に取得し、元のパスと実体のパスの
            ユニークなマッピングを返します。
            """
            path_map = {}
            processed_paths = set()
            to_process = list(filepaths)

            filter_pattern = '|'.join([re.escape(p) for p in filter_prefixes])
            filter_regex = re.compile(f'({filter_pattern})')

            while to_process:
                current_file = to_process.pop(0)

                if current_file in processed_paths:
                    continue
                processed_paths.add(current_file)
                
                try:
                    result = subprocess.run(
                        ['otool', '-L', current_file],
                        capture_output=True,
                        text=True,
                        check=True
                    )
                    output = result.stdout
                except (subprocess.CalledProcessError, FileNotFoundError):
                    continue

                for line in output.splitlines():
                    match = re.search(r'\s+([^\s]+)\s+\(compatibility version', line)
                    if match:
                        linked_dylib = match.group(1)
                        
                        # @rpath や @loader_path の依存関係も検出対象に含める
                        real_path = linked_dylib
                        if linked_dylib.startswith('@rpath/'):
                            # @rpath を元のパスのプレフィックスに置き換えて実体パスを推測
                            guessed_path = linked_dylib.replace('@rpath', filter_prefixes[0])
                            real_path = os.path.realpath(guessed_path)
                        elif not os.path.isabs(linked_dylib):
                            continue

                        if filter_regex.match(real_path):
                            if real_path not in path_map:
                                path_map[real_path] = linked_dylib
                                if real_path not in processed_paths:
                                    to_process.append(real_path)
            return path_map

        def setup_directory_structure(root_dir="mpv"):
            """
            mpv/bin と mpv/lib のディレクトリ構造を作成します。
            """
            print(f"ディレクトリ構造を作成中: {root_dir}")
            bin_path = os.path.join(os.getcwd(), root_dir, "bin")
            lib_path = os.path.join(os.getcwd(), root_dir, "lib")
            os.makedirs(bin_path, exist_ok=True)
            os.makedirs(lib_path, exist_ok=True)
            return bin_path, lib_path

        def copy_files(path_map, lib_path):
            """
            dylibと実行可能ファイルをそれぞれのディレクトリにコピーします。
            """
            print("必要なファイルをコピー中...")
            copied_map = {}
            for real_path, original_path in path_map.items():
                try:
                    dest_filename = os.path.basename(real_path)
                    dest_path = os.path.join(lib_path, dest_filename)
                    
                    if not os.path.exists(dest_path):
                        shutil.copy2(real_path, dest_path)
                        print(f"コピー: {real_path} -> {dest_path}")
                    
                    copied_map[original_path] = dest_path

                except FileNotFoundError:
                    print(f"警告: ファイルが見つかりません: {original_path}")
                except Exception as e:
                    print(f"エラー: {original_path} のコピー中に問題が発生しました: {e}")
            return copied_map

        def fix_paths_relative(executable_path, lib_path, copied_map):
            """
            すべてのファイルパスを相対パスに修正します。
            """
            print("すべてのパスを相対パスに修正中...")
            
            # 実行可能ファイルのrpathを追加
            rpath_cmd = ["install_name_tool", "-add_rpath", "@loader_path/../lib", executable_path]
            subprocess.run(rpath_cmd, check=True)
            
            # 実行可能ファイルの依存パスを修正
            try:
                otool_output = subprocess.run(['otool', '-L', executable_path], capture_output=True, text=True, check=True).stdout
                for line in otool_output.splitlines():
                    match = re.search(r'\s+([^\s]+)\s+\(compatibility version', line)
                    if match:
                        old_path = match.group(1)
                        if old_path in copied_map or old_path.startswith('@rpath/'):
                            new_path = f"@loader_path/../lib/{os.path.basename(copied_map[old_path])}"
                            change_cmd = ["install_name_tool", "-change", old_path, new_path, executable_path]
                            subprocess.run(change_cmd, check=True)
                            print(f"変更: {os.path.basename(executable_path)} の {old_path} -> {new_path}")
            except Exception as e:
                print(f"エラー: 実行可能ファイルのパス修正中に問題が発生しました: {e}")

            # dylibのIDと依存パスを修正
            for original_path, copied_path in copied_map.items():
                try:
                    # 自分のIDを修正
                    new_id = f"@loader_path/{os.path.basename(copied_path)}"
                    id_cmd = ["install_name_tool", "-id", new_id, copied_path]
                    subprocess.run(id_cmd, check=True)
                    print(f"ID変更: {os.path.basename(copied_path)} のIDを {new_id} に設定")

                    # 依存するdylibのパスを修正
                    otool_output = subprocess.run(['otool', '-L', copied_path], capture_output=True, text=True, check=True).stdout
                    for line in otool_output.splitlines():
                        match = re.search(r'\s+([^\s]+)\s+\(compatibility version', line)
                        if match:
                            old_path = match.group(1)
                            if old_path in copied_map or old_path.startswith('@rpath/'):
                                new_path = f"@loader_path/{os.path.basename(copied_map[old_path])}"
                                change_cmd = ["install_name_tool", "-change", old_path, new_path, copied_path]
                                subprocess.run(change_cmd, check=True)
                                print(f"変更: {os.path.basename(copied_path)} の {old_path} -> {new_path}")
                except Exception as e:
                    print(f"エラー: {copied_path} のパス修正中に問題が発生しました: {e}")

        def re_codesign(root_dir="mpv"):
            """
            指定されたディレクトリ内のすべての実行可能ファイルとdylibに再署名します。
            """
            print("すべてのファイルに再署名中...")
            bin_path = os.path.join(os.getcwd(), root_dir, "bin")
            lib_path = os.path.join(os.getcwd(), root_dir, "lib")
            
            # libディレクトリ内のdylibに署名
            if os.path.exists(lib_path):
                for filename in os.listdir(lib_path):
                    filepath = os.path.join(lib_path, filename)
                    if os.path.isfile(filepath):
                        sign_cmd = ["codesign", "--force", "--sign", "-", filepath]
                        try:
                            subprocess.run(sign_cmd, check=True)
                            print(f"署名済み: {filepath}")
                        except subprocess.CalledProcessError as e:
                            print(f"警告: {filepath} の署名に失敗しました: {e}")
            
            # binディレクトリ内の実行可能ファイルに署名
            if os.path.exists(bin_path):
                for filename in os.listdir(bin_path):
                    filepath = os.path.join(bin_path, filename)
                    if os.path.isfile(filepath):
                        sign_cmd = ["codesign", "--force", "--sign", "-", filepath]
                        try:
                            subprocess.run(sign_cmd, check=True)
                            print(f"署名済み: {filepath}")
                        except subprocess.CalledProcessError as e:
                            print(f"警告: {filepath} の署名に失敗しました: {e}")

        if __name__ == "__main__":
            # --- 設定 ---
            target_executable = "/opt/homebrew/bin/mpv"
            # 追加のシードとなるdylibリスト
            extra_dylibs = [
                "/opt/homebrew/lib/libass.dylib",
                "/opt/homebrew/lib/libavcodec.dylib",
                "/opt/homebrew/lib/libavdevice.dylib",
                "/opt/homebrew/lib/libavfilter.dylib",
                "/opt/homebrew/lib/libavformat.dylib",
                "/opt/homebrew/lib/libavutil.dylib",
                "/opt/homebrew/lib/libmpv.dylib",
                "/opt/homebrew/lib/libplacebo.dylib",
                "/opt/homebrew/lib/libswscale.dylib",
                "/opt/homebrew/lib/libunibreak.dylib",
                # エラーログから見つからなかったライブラリを追加
                "/opt/homebrew/lib/libwebp.dylib",
                "/opt/homebrew/lib/libjxl_cms.dylib",
                "/opt/homebrew/lib/libsharpyuv.dylib"
            ]
            # 検索対象とするプレフィックス
            filter_prefixes = [
                "/opt/homebrew",
                "/Users/koba/Desktop/sinage/sample_mpv" # このパスはGitHub Actionsランナーでは存在しないため、除外しても良い
            ]
            root_dir = "mpv"
            # -----------
            
            # ステップ1: dylibの依存関係を再帰的に取得
            print("dylibの依存関係を再帰的に取得中...")
            seed_files = [target_executable] + extra_dylibs
            path_map = get_linked_and_real_paths(seed_files, filter_prefixes)
            
            # ステップ2: ディレクトリ構造を作成
            bin_path, lib_path = setup_directory_structure(root_dir)
            
            # ステップ3: mpv実行可能ファイルをコピー
            executable_name = os.path.basename(target_executable)
            dest_executable_path = os.path.join(bin_path, executable_name)
            shutil.copy2(target_executable, dest_executable_path)
            print(f"実行可能ファイルをコピー: {target_executable} -> {dest_executable_path}")
            
            # ステップ4: dylibをコピー
            copied_map = copy_files(path_map, lib_path)
            
            # ステップ5: すべてのパスを相対パスに修正
            fix_paths_relative(dest_executable_path, lib_path, copied_map)
            
            # ステップ6: 再署名
            re_codesign(root_dir)
            
            print("\n--- 完了 ---")
            print(f"作成されたディレクトリ: {os.path.join(os.getcwd(), root_dir)}")
            print("これでmpv/bin/mpvから相対パスでdylibが参照されるようになります。")
        EOF

        # スクリプトを実行
        python build_mpv.py

    - name: mpvディレクトリをtar.gzに圧縮
      id: compress_mpv
      run: |
        tar -czf mpv.tar.gz mpv
        echo "asset_name=mpv.tar.gz" >> $GITHUB_OUTPUT

    - name: リリース作成
      id: create_release
      uses: softprops/action-gh-release@v1
      with:
        files: mpv.tar.gz
        tag_name: ${{ github.event.inputs.version }}
        name: mpv ${{ github.event.inputs.version }}
        draft: true
        prerelease: false
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
