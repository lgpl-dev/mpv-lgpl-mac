name: Build and Release mpv

on:
  workflow_dispatch:
    inputs:
      version:
        description: 'mpvのバージョン (例: v0.40.0)'
        required: true
        default: 'v0.40.0'

jobs:
  build_and_release:
    runs-on: macos-13
    permissions:
      contents: write
    
    steps:
    - name: チェックアウト
      uses: actions/checkout@v4
      with:
        fetch-depth: 0 # 既存のタグを取得するために完全な履歴を取得する

    - name: タグの作成とプッシュ
      id: create_tag
      run: |
        TAG_NAME=${{ github.event.inputs.version }}
        echo "Creating and pushing tag: $TAG_NAME"
        git tag $TAG_NAME
        git push origin $TAG_NAME

    - name: Homebrew環境のセットアップ
      run: |
        brew tap lgpl-dev/ffmpeg-lgpl
        brew tap lgpl-dev/mpv-lgpl
        brew install ffmpeg-lgpl mpv-lgpl python
        which otool
        which install_name_tool

    - name: スクリプトの実行パスを動的に取得
      id: get_paths
      run: |
        MPV_BIN_PATH=$(brew --prefix mpv-lgpl)/bin/mpv
        HOMEBREW_PREFIX=$(brew --prefix)

        echo "MPV_BIN_PATH=$MPV_BIN_PATH" >> $GITHUB_ENV
        echo "HOMEBREW_PREFIX=$HOMEBREW_PREFIX" >> $GITHUB_ENV

    - name: スクリプトの保存と実行
      id: run_script
      env:
        MPV_BIN_PATH: ${{ env.MPV_BIN_PATH }}
        HOMEBREW_PREFIX: ${{ env.HOMEBREW_PREFIX }}
      run: |
        cat << 'EOF' > build_mpv.py
        import subprocess
        import re
        import os
        import shutil

        def get_linked_and_real_paths(filepaths, filter_prefixes):
            path_map = {}
            processed_paths = set()
            to_process = list(filepaths)
            filter_pattern = '|'.join([re.escape(p) for p in filter_prefixes])
            filter_regex = re.compile(f'({filter_pattern})')
            while to_process:
                current_file = to_process.pop(0)
                if current_file in processed_paths:
                    continue
                processed_paths.add(current_file)
                try:
                    result = subprocess.run(
                        ['otool', '-L', current_file],
                        capture_output=True,
                        text=True,
                        check=True
                    )
                    output = result.stdout
                except (subprocess.CalledProcessError, FileNotFoundError):
                    continue
                for line in output.splitlines():
                    match = re.search(r'\s+([^\s]+)\s+\(compatibility version', line)
                    if match:
                        linked_dylib = match.group(1)
                        real_path = linked_dylib
                        if linked_dylib.startswith('@rpath/'):
                            guessed_path = linked_dylib.replace('@rpath', filter_prefixes[0])
                            real_path = os.path.realpath(guessed_path)
                        elif not os.path.isabs(linked_dylib):
                            continue
                        if filter_regex.match(real_path):
                            if real_path not in path_map:
                                path_map[real_path] = linked_dylib
                                if real_path not in processed_paths:
                                    to_process.append(real_path)
            return path_map
        def setup_directory_structure(root_dir="mpv"):
            print(f"ディレクトリ構造を作成中: {root_dir}")
            bin_path = os.path.join(os.getcwd(), root_dir, "bin")
            lib_path = os.path.join(os.getcwd(), root_dir, "lib")
            os.makedirs(bin_path, exist_ok=True)
            os.makedirs(lib_path, exist_ok=True)
            return bin_path, lib_path
        def copy_files(path_map, lib_path):
            print("必要なファイルをコピー中...")
            copied_map = {}
            for real_path, original_path in path_map.items():
                try:
                    dest_filename = os.path.basename(real_path)
                    dest_path = os.path.join(lib_path, dest_filename)
                    if not os.path.exists(dest_path):
                        shutil.copy2(real_path, dest_path)
                        print(f"コピー: {real_path} -> {dest_path}")
                    copied_map[original_path] = dest_path
                except FileNotFoundError:
                    print(f"警告: ファイルが見つかりません: {original_path}")
                except Exception as e:
                    print(f"エラー: {original_path} のコピー中に問題が発生しました: {e}")
            return copied_map
        def fix_paths_relative(executable_path, lib_path, copied_map):
            print("すべてのパスを相対パスに修正中...")
            rpath_cmd = ["install_name_tool", "-add_rpath", "@loader_path/../lib", executable_path]
            subprocess.run(rpath_cmd, check=True)
            try:
                otool_output = subprocess.run(['otool', '-L', executable_path], capture_output=True, text=True, check=True).stdout
                for line in otool_output.splitlines():
                    match = re.search(r'\s+([^\s]+)\s+\(compatibility version', line)
                    if match:
                        old_path = match.group(1)
                        if old_path in copied_map or old_path.startswith('@rpath/'):
                            new_path = f"@loader_path/../lib/{os.path.basename(copied_map[old_path])}"
                            change_cmd = ["install_name_tool", "-change", old_path, new_path, executable_path]
                            subprocess.run(change_cmd, check=True)
                            print(f"変更: {os.path.basename(executable_path)} の {old_path} -> {new_path}")
            except Exception as e:
                print(f"エラー: 実行可能ファイルのパス修正中に問題が発生しました: {e}")
            for original_path, copied_path in copied_map.items():
                try:
                    new_id = f"@loader_path/{os.path.basename(copied_path)}"
                    id_cmd = ["install_name_tool", "-id", new_id, copied_path]
                    subprocess.run(id_cmd, check=True)
                    print(f"ID変更: {os.path.basename(copied_path)} のIDを {new_id} に設定")
                    otool_output = subprocess.run(['otool', '-L', copied_path], capture_output=True, text=True, check=True).stdout
                    for line in otool_output.splitlines():
                        match = re.search(r'\s+([^\s]+)\s+\(compatibility version', line)
                        if match:
                            old_path = match.group(1)
                            if old_path in copied_map or old_path.startswith('@rpath/'):
                                new_path = f"@loader_path/{os.path.basename(copied_map[old_path])}"
                                change_cmd = ["install_name_tool", "-change", old_path, new_path, copied_path]
                                subprocess.run(change_cmd, check=True)
                                print(f"変更: {os.path.basename(copied_path)} の {old_path} -> {new_path}")
                except Exception as e:
                    print(f"エラー: {copied_path} のパス修正中に問題が発生しました: {e}")
        def re_codesign(root_dir="mpv"):
            print("すべてのファイルに再署名中...")
            bin_path = os.path.join(os.getcwd(), root_dir, "bin")
            lib_path = os.path.join(os.getcwd(), root_dir, "lib")
            if os.path.exists(lib_path):
                for filename in os.listdir(lib_path):
                    filepath = os.path.join(lib_path, filename)
                    if os.path.isfile(filepath):
                        sign_cmd = ["codesign", "--force", "--sign", "-", filepath]
                        try:
                            subprocess.run(sign_cmd, check=True)
                            print(f"署名済み: {filepath}")
                        except subprocess.CalledProcessError as e:
                            print(f"警告: {filepath} の署名に失敗しました: {e}")
            if os.path.exists(bin_path):
                for filename in os.listdir(bin_path):
                    filepath = os.path.join(bin_path, filename)
                    if os.path.isfile(filepath):
                        sign_cmd = ["codesign", "--force", "--sign", "-", filepath]
                        try:
                            subprocess.run(sign_cmd, check=True)
                            print(f"署名済み: {filepath}")
                        except subprocess.CalledProcessError as e:
                            print(f"警告: {filepath} の署名に失敗しました: {e}")
        if __name__ == "__main__":
            target_executable = os.environ.get('MPV_BIN_PATH')
            homebrew_prefix = os.environ.get('HOMEBREW_PREFIX')
            extra_dylibs = [
                f"{homebrew_prefix}/lib/libass.dylib",
                f"{homebrew_prefix}/lib/libavcodec.dylib",
                f"{homebrew_prefix}/lib/libavdevice.dylib",
                f"{homebrew_prefix}/lib/libavfilter.dylib",
                f"{homebrew_prefix}/lib/libavformat.dylib",
                f"{homebrew_prefix}/lib/libavutil.dylib",
                f"{homebrew_prefix}/lib/libmpv.dylib",
                f"{homebrew_prefix}/lib/libplacebo.dylib",
                f"{homebrew_prefix}/lib/libswscale.dylib",
                f"{homebrew_prefix}/lib/libunibreak.dylib",
                f"{homebrew_prefix}/lib/libwebp.dylib",
                f"{homebrew_prefix}/lib/libjxl_cms.dylib",
                f"{homebrew_prefix}/lib/libsharpyuv.dylib"
            ]
            filter_prefixes = [
                f"{homebrew_prefix}"
            ]
            root_dir = "mpv"
            print("dylibの依存関係を再帰的に取得中...")
            seed_files = [target_executable] + extra_dylibs
            path_map = get_linked_and_real_paths(seed_files, filter_prefixes)
            bin_path, lib_path = setup_directory_structure(root_dir)
            executable_name = os.path.basename(target_executable)
            dest_executable_path = os.path.join(bin_path, executable_name)
            shutil.copy2(target_executable, dest_executable_path)
            print(f"実行可能ファイルをコピー: {target_executable} -> {dest_executable_path}")
            copied_map = copy_files(path_map, lib_path)
            fix_paths_relative(dest_executable_path, lib_path, copied_map)
            re_codesign(root_dir)
            print("\n--- 完了 ---")
            print(f"作成されたディレクトリ: {os.path.join(os.getcwd(), root_dir)}")
            print("これでmpv/bin/mpvから相対パスでdylibが参照されるようになります。")
        EOF

        python build_mpv.py

    - name: mpvディレクトリをtar.gzに圧縮
      id: compress_mpv
      run: |
        tar -czf mpv.tar.gz mpv
        echo "asset_name=mpv.tar.gz" >> $GITHUB_OUTPUT

    - name: リリース作成
      id: create_release
      uses: softprops/action-gh-release@v1
      with:
        files: mpv.tar.gz
        tag_name: ${{ github.event.inputs.version }}
        name: mpv ${{ github.event.inputs.version }}
        draft: true
        prerelease: false
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
